#include <stdio.h>
#include <string.h>
#include "retrossl_rsa.h"

void hexdump_line(const unsigned char *data, size_t len) {
    size_t i;
    for (i = 0; i < len; i++) {
        printf("%02X ", data[i]);
    }
    printf("\n");
}

int main()
{
    printf("RetroSSL RSA Test\n");
    printf("=================\n\n");

    printf("Testing basic i31 decode/encode functions...\n");

    {
        unsigned char data[4] = {0x01, 0x23, 0x45, 0x67};
        uint32_t x[10];
        unsigned char result[4];
        
        printf("Input: ");
        hexdump_line(data, 4);
        
        br_i31_decode(x, data, 4);
        printf("Decoded x[0] (bit length): %lu\n", (unsigned long)x[0]);
        printf("Decoded x[1]: 0x%08lX\n", (unsigned long)x[1]);
        
        br_i31_encode(result, 4, x);
        printf("Re-encoded: ");
        hexdump_line(result, 4);
        
        if (memcmp(data, result, 4) == 0) {
            printf("PASS: Round-trip encode/decode successful\n");
        } else {
            printf("FAIL: Round-trip encode/decode failed\n");
        }
    }

    printf("\nTesting bit length function...\n");
    {
        uint32_t x[3] = {32, 0x12345678, 0x00000000};
        uint32_t len = br_i31_bit_length(x + 1, 1);
        printf("Bit length of 0x12345678: %lu\n", (unsigned long)len);
    }

    printf("\nTesting ninv31 function...\n");
    {
        uint32_t x = 0x12345679;  /* odd number */
        uint32_t inv = br_i31_ninv31(x);
        printf("ninv31(0x%08lX) = 0x%08lX\n", (unsigned long)x, (unsigned long)inv);
    }

    printf("\nTesting Montgomery arithmetic...\n");
    {
        /* Simple test: compute 3^5 mod 7 = 5 */
        uint32_t base[3] = {32, 3, 0};      /* base = 3 */
        uint32_t mod[3] = {32, 7, 0};       /* modulus = 7 */
        unsigned char exp[1] = {5};          /* exponent = 5 */
        uint32_t tmp[20];                    /* temporary space */
        uint32_t m0i;
        uint32_t result;
        
        m0i = br_i31_ninv31(7);
        printf("Computing 3^5 mod 7...\n");
        printf("m0i = 0x%08lX\n", (unsigned long)m0i);
        printf("Base before: %lu\n", (unsigned long)base[1]);
        
        if (br_i31_modpow_opt(base, exp, 1, mod, m0i, tmp, 20)) {
            result = base[1];
            printf("Result: %lu (expected: 5)\n", (unsigned long)result);
            if (result == 5) {
                printf("PASS: Modular exponentiation test\n");
            } else {
                printf("FAIL: Modular exponentiation test\n");
            }
        } else {
            printf("FAIL: Modular exponentiation failed\n");
        }
    }
    
    printf("\nTesting Montgomery domain conversion...\n");
    {
        uint32_t x[3] = {32, 3, 0};         /* x = 3 */
        uint32_t mod[3] = {32, 7, 0};       /* modulus = 7 */
        uint32_t m0i = br_i31_ninv31(7);
        
        printf("Original x: %lu\n", (unsigned long)x[1]);
        printf("m0i = 0x%08lX\n", (unsigned long)m0i);
        printf("mod[0] = %lu, mod[1] = %lu\n", (unsigned long)mod[0], (unsigned long)mod[1]);
        
        /* Convert to Montgomery domain */
        br_i31_to_monty(x, mod);
        printf("After to_monty: x[1] = %lu, x[2] = %lu\n", (unsigned long)x[1], (unsigned long)x[2]);
        
        /* Convert back from Montgomery domain */
        br_i31_from_monty(x, mod, m0i);
        printf("After from_monty: x[1] = %lu, x[2] = %lu\n", (unsigned long)x[1], (unsigned long)x[2]);
        
        if (x[1] == 3) {
            printf("PASS: Montgomery domain conversion\n");
        } else {
            printf("FAIL: Montgomery domain conversion\n");
        }
    }

    printf("\nTesting RSA public key operation with OpenSSL-generated key...\n");
    {
        /* Real 512-bit RSA key generated with OpenSSL */
        /* Modulus: C494EE34C1D75CF4545CB70066AB04068252E581F17C231AA9C9040DACED902F981517739BB48A445AACE98752ED1C526374A5907673CE0BB33E3B97B5800823 */
        unsigned char modulus[] = {
            0xC4, 0x94, 0xEE, 0x34, 0xC1, 0xD7, 0x5C, 0xF4, 
            0x54, 0x5C, 0xB7, 0x00, 0x66, 0xAB, 0x04, 0x06,
            0x82, 0x52, 0xE5, 0x81, 0xF1, 0x7C, 0x23, 0x1A, 
            0xA9, 0xC9, 0x04, 0x0D, 0xAC, 0xED, 0x90, 0x2F,
            0x98, 0x15, 0x17, 0x73, 0x9B, 0xB4, 0x8A, 0x44, 
            0x5A, 0xAC, 0xE9, 0x87, 0x52, 0xED, 0x1C, 0x52,
            0x63, 0x74, 0xA5, 0x90, 0x76, 0x73, 0xCE, 0x0B, 
            0xB3, 0x3E, 0x3B, 0x97, 0xB5, 0x80, 0x08, 0x23
        };
        unsigned char exponent[] = { 0x01, 0x00, 0x01 }; /* 65537 */
        
        /* Signature generated by OpenSSL for message "Hello RetroSSL RSA!\n" */
        unsigned char signature[] = {
            0x1E, 0xBC, 0x9D, 0x7D, 0x4E, 0xD6, 0x82, 0x47,
            0xE7, 0xC8, 0x3F, 0xD9, 0x2C, 0x79, 0x81, 0x5F,
            0x25, 0xD5, 0x83, 0x75, 0x6C, 0x34, 0x2D, 0xB0,
            0xD7, 0xBD, 0xC4, 0x8B, 0xB4, 0xE8, 0xE0, 0x14,
            0x7B, 0x2B, 0xD9, 0x9F, 0xAA, 0xB2, 0x0F, 0x6E,
            0x7A, 0x20, 0x8B, 0x4F, 0x8A, 0xAE, 0xED, 0x36,
            0xD8, 0x09, 0x75, 0x98, 0xD6, 0x27, 0x86, 0x71,
            0x0A, 0xB8, 0x4E, 0xE5, 0x56, 0x08, 0xDB, 0x85
        };
        
        br_rsa_public_key pubkey;
        unsigned char buffer[64];
        uint32_t result;
        
        pubkey.n = modulus;
        pubkey.nlen = sizeof(modulus);
        pubkey.e = exponent;
        pubkey.elen = sizeof(exponent);
        
        memcpy(buffer, signature, sizeof(signature));
        
        printf("OpenSSL RSA Key Details:\n");
        printf("  Modulus length: %u bytes\n", (unsigned)pubkey.nlen);
        printf("  Modulus (first 16 bytes): ");
        hexdump_line(pubkey.n, 16);
        printf("  Public exponent: ");
        hexdump_line(pubkey.e, pubkey.elen);
        
        printf("OpenSSL signature (first 16 bytes): ");
        hexdump_line(signature, 16);
        
        /* Debug: Check the intermediate values */
        {
            uint32_t test_decoded[20];
            uint32_t m0i_test;
            
            printf("Debug: Checking key validation steps...\n");
            printf("  nlen=%u, xlen=%u, BR_MAX_RSA_SIZE>>3=%u\n", 
                   (unsigned)pubkey.nlen, (unsigned)sizeof(signature), (unsigned)(BR_MAX_RSA_SIZE >> 3));
            
            br_i31_decode(test_decoded, pubkey.n, pubkey.nlen);
            printf("  First decoded word: 0x%08lX\n", (unsigned long)test_decoded[1]);
            
            m0i_test = br_i31_ninv31(test_decoded[1]);
            printf("  m0i = 0x%08lX, m0i & 1 = %u\n", (unsigned long)m0i_test, (unsigned)(m0i_test & 1));
        }
        
        printf("Performing RSA signature verification (public operation)...\n");
        result = br_rsa_i31_public(buffer, sizeof(signature), &pubkey);
        
        printf("Operation result: %u (1=success, 0=failure)\n", result);
        if (result) {
            printf("Decrypted signature (first 16 bytes): ");
            hexdump_line(buffer, 16);
            printf("Expected SHA1 DigestInfo prefix: 30 21 30 09 06 05 2B 0E 03 02 1A 05 00 04 14\n");
            printf("PASS: RSA interoperability test completed\n");
            printf("NOTE: Full PKCS#1 padding verification requires additional parsing\n");
        } else {
            printf("FAIL: RSA public key operation failed\n");
        }
    }

    printf("\nRSA i31 functions test completed.\n");
    return 0;
}
